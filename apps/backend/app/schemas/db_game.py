"""Pydantic schemas for the unified Game model (RAWG-sourced and custom)."""

import uuid
from datetime import date
from typing import List, Optional

from pydantic import BaseModel, ConfigDict

# Import the base model class directly from the models module
# to ensure schema fields align with model fields for creation.
from app.models.model_game import GameBase as GameModelBase


# --- Schema for Creating Games ---
class GameCreateSchema(GameModelBase):
    """Schema used for creating a new Game record (RAWG or custom).

    Inherits fields from the model's GameBase (rawg_id, slug, name, etc.).
    Includes flags and fields necessary for distinguishing and creating custom games.
    """

    is_custom: bool = False  # Flag to indicate if the game is custom-added
    # Optional admin ID, relevant only if is_custom is True
    created_by_admin_id: Optional[str] = None

    # Slug might be optional during creation for custom games,
    # as it can be generated by CRUD based on the name.
    # We'll keep it required as per GameModelBase for now,
    # CRUD logic handles generation if needed.
    # slug: Optional[str] = None


# --- Schema for Reading/Returning Games ---
class GamePublicSchema(BaseModel):
    """Schema for returning Game data via the API."""

    id: uuid.UUID  # Local database ID
    is_custom: bool
    rawg_id: Optional[int] = None  # RAWG ID (null for custom)
    slug: str
    name: str
    released_date: Optional[date] = None
    background_image: Optional[str] = None
    rating: Optional[float] = None
    metacritic: Optional[int] = None
    playtime: Optional[int] = None
    description: Optional[str] = None  # Description (mainly for custom)
    # Add other fields as needed for the API response (e.g., rating_top, ratings_count)

    model_config = ConfigDict(from_attributes=True)  # Pydantic v2 config


# --- Schema for Listing Games ---
class GameListSchema(BaseModel):
    """Schema for returning a list of games with count."""

    results: List[GamePublicSchema]
    count: int


# Note on API Response Compatibility (e.g., /products endpoint):
# The existing /products endpoint might expect a structure like the RAWG API response
# (often including 'next', 'previous' fields and specific field names/structures).
# When using these new schemas with that endpoint, ensure:
# 1. The data retrieved using CRUD (which returns model instances) is mapped
#    to GamePublicSchema correctly (using `model_validate` or similar).
# 2. The final response structure matches what the frontend/client expects.
#    This might involve creating a wrapper response model similar to the old
#    ProductListingResponse but using GamePublicSchema in its 'results',
#    or transforming the GameListSchema output.
